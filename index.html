<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MATECITOS 游븰</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }
    h1 {
      margin-top: 20px;
    }
    /* Contenedor para el selector de mapa */
    #mapSelectorContainer {
      margin: 10px;
    }
    #mapSelector {
      padding: 5px;
      font-size: 16px;
    }
    /* Contenedor para el tablero, permite scroll horizontal en m칩viles */
    .board-container {
      width: 100%;
      overflow-x: auto;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .board {
      display: grid;
      gap: 2px;
      border: 2px solid #333;
      margin: auto;
    }
    .cell {
      /* El tama침o se fijar치 din치micamente v칤a JS (50px para desktop, 40px para mobile) */
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      position: relative;
    }
    .cell.highlight {
      outline: 3px solid red;
    }
    .controls {
      margin: 10px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      min-width: 120px;
    }
    button:hover {
      background-color: #45a049;
    }
    .rules-pill {
      margin-top: 20px;
      background-color: #dff0d8;
      border: 1px solid #c3e6cb;
      border-radius: 25px;
      padding: 10px 20px;
      font-size: 14px;
      text-align: left;
      max-width: 400px;
    }
    .rules-pill p {
      margin: 5px 0;
    }
    .rules-pill ul {
      padding-left: 20px;
      margin: 0;
    }
    .rules-pill li {
      margin: 5px 0;
    }
    /* Media queries para pantallas peque침as */
    @media (max-width: 480px) {
      .cell {
        font-size: 20px;
      }
      button {
        font-size: 14px;
        padding: 8px 16px;
        min-width: 100px;
      }
      .rules-pill {
        max-width: 90%;
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
  <h1>MATECITOS 游븰</h1>
  <!-- Selector de mapa (actualizado a 10 niveles) -->
  <div id="mapSelectorContainer">
    <select id="mapSelector" onchange="selectMap()">
      <option value="0">Mapa 1</option>
      <option value="1">Mapa 2</option>
      <option value="2">Mapa 3</option>
      <option value="3">Mapa 4</option>
      <option value="4">Mapa 5</option>
      <option value="5">Mapa 6</option>
      <option value="6">Mapa 7</option>
      <option value="7">Mapa 8</option>
      <option value="8">Mapa 9</option>
      <option value="9">Mapa 10</option>
    </select>
  </div>
  
  <div class="board-container">
    <div id="board" class="board"></div>
  </div>
  <div class="controls">
    <button onclick="resetGame()">Reset Nivel</button>
    <button onclick="nextLevel()">Siguiente Nivel</button>
    <button onclick="randomLevel()">Random</button>
  </div>
  <div class="rules-pill">
    <p><strong>C칩mo jugar a Matecitos 游븰</strong></p>
    <ul>
      <li>Tu objetivo es tener exactamente un 游븰 en cada fila, columna y regi칩n de color.</li>
      <li>Pulsa una vez para colocar un 游븰 y pulsa dos veces para colocar una X. Usa la X para marcar d칩nde no se puede colocar un 游븰.</li>
      <li>Dos 游븰 no pueden tocarse entre s칤, ni siquiera en diagonal.</li>
    </ul>
  </div>

  <script>
    // Colores base para niveles 5x5
    const colors5 = { "1": "#FFDDC1", "2": "#FFABAB", "3": "#FFC3A0", "4": "#D5AAFF", "5": "#85E3FF" };

    /* Definici칩n de los 10 niveles nuevos (todos 5칑5).
       Cada matriz es una representaci칩n del tablero.
       Cada n칰mero representa una regi칩n (el color se asigna mediante colors5).
       Se ha verificado que, para cada nivel, las celdas de cada regi칩n est치n conectadas ortogonalmente.
    */
    const levels = [
      { board: [
          [1,1,2,2,2],
          [1,3,3,2,2],
          [1,3,3,5,2],
          [4,3,5,5,5],
          [4,4,4,5,5]
        ], regionColors: colors5 },
      { board: [
          [1,1,1,2,2],
          [1,3,3,2,2],
          [1,3,4,5,5],
          [1,3,4,4,5],
          [1,3,4,4,4]
        ], regionColors: colors5 },
      { board: [
          [1,2,2,2,5],
          [1,1,3,2,5],
          [1,3,3,5,5],
          [4,3,3,5,5],
          [4,4,4,5,5]
        ], regionColors: colors5 },
      { board: [
          [1,1,5,5,2],
          [1,3,5,5,2],
          [1,3,5,5,2],
          [4,3,3,5,2],
          [4,4,3,5,2]
        ], regionColors: colors5 },
      { board: [
          [1,3,3,5,5],
          [1,1,3,5,2],
          [4,1,3,2,2],
          [4,4,3,2,2],
          [4,4,4,2,2]
        ], regionColors: colors5 },
      { board: [
          [1,1,5,5,5],
          [1,3,3,5,2],
          [1,3,3,2,2],
          [4,3,3,2,2],
          [4,4,3,2,2]
        ], regionColors: colors5 },
      { board: [
          [1,3,3,2,2],
          [1,1,3,2,2],
          [1,1,5,2,2],
          [4,4,5,5,5],
          [4,4,4,5,5]
        ], regionColors: colors5 },
      { board: [
          [1,1,3,3,2],
          [1,3,3,2,2],
          [1,3,5,2,2],
          [4,3,5,5,5],
          [4,4,4,5,5]
        ], regionColors: colors5 },
      { board: [
          [1,1,1,2,2],
          [1,4,4,2,2],
          [1,4,5,3,3],
          [1,4,5,5,5],
          [1,4,5,5,5]
        ], regionColors: colors5 },
      { board: [
          [1,1,3,3,3],
          [1,3,3,2,2],
          [1,3,5,2,2],
          [4,4,5,5,5],
          [4,4,4,5,5]
        ], regionColors: colors5 }
    ];

    let currentLevelIndex = 0;
    let board = document.getElementById("board");
    let cells = [];
    let boardSize;
    let errorTimeout;

    function loadLevel(levelIndex) {
      clearTimeout(errorTimeout);
      cells = [];
      board.innerHTML = "";
      const level = levels[levelIndex];
      boardSize = level.board.length;
      let cellSize = window.innerWidth < 480 ? 40 : 50;
      let gap = 2;
      board.style.gridTemplateColumns = `repeat(${boardSize}, ${cellSize}px)`;
      board.style.gridTemplateRows = `repeat(${boardSize}, ${cellSize}px)`;
      board.style.width = (boardSize * cellSize + (boardSize - 1) * gap) + "px";
      board.style.height = (boardSize * cellSize + (boardSize - 1) * gap) + "px";
      let regionKeys = Object.keys(level.regionColors).sort((a, b) => a - b);
      let offset = levelIndex % regionKeys.length;
      let newMapping = {};
      for (let i = 0; i < regionKeys.length; i++) {
        newMapping[regionKeys[i]] = level.regionColors[regionKeys[(i + offset) % regionKeys.length]];
      }
      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          cell.dataset.row = row;
          cell.dataset.col = col;
          cell.dataset.region = level.board[row][col];
          cell.style.backgroundColor = newMapping[cell.dataset.region];
          cell.dataset.state = "empty";
          cell.style.width = cellSize + "px";
          cell.style.height = cellSize + "px";
          cell.addEventListener("click", () => toggleCell(cell));
          board.appendChild(cell);
          cells.push(cell);
        }
      }
    }

    function toggleCell(cell) {
      if (cell.dataset.state === "empty") {
        cell.textContent = "游븰";
        cell.dataset.state = "mate";
      } else if (cell.dataset.state === "mate") {
        cell.textContent = "X";
        cell.dataset.state = "x";
      } else {
        cell.textContent = "";
        cell.dataset.state = "empty";
      }
      cell.classList.remove("highlight");
      clearTimeout(errorTimeout);
      errorTimeout = setTimeout(() => {
        checkErrors();
        checkWin();
      }, 1500);
    }

    function checkErrors() {
      cells.forEach(cell => cell.classList.remove("highlight"));
      const errors = new Set();
      const rows = {};
      const cols = {};
      const regions = {};
      cells.forEach(cell => {
        if (cell.dataset.state === "mate") {
          const r = cell.dataset.row;
          const c = cell.dataset.col;
          const reg = cell.dataset.region;
          if (!rows[r]) rows[r] = [];
          rows[r].push(cell);
          if (!cols[c]) cols[c] = [];
          cols[c].push(cell);
          if (!regions[reg]) regions[reg] = [];
          regions[reg].push(cell);
        }
      });
      Object.values(rows).forEach(group => {
        if (group.length > 1) group.forEach(cell => errors.add(cell));
      });
      Object.values(cols).forEach(group => {
        if (group.length > 1) group.forEach(cell => errors.add(cell));
      });
      Object.values(regions).forEach(group => {
        if (group.length > 1) group.forEach(cell => errors.add(cell));
      });
      cells.forEach(cell => {
        if (cell.dataset.state === "mate") {
          const r = parseInt(cell.dataset.row);
          const c = parseInt(cell.dataset.col);
          const neighbors = [
            [r - 1, c - 1],
            [r - 1, c],
            [r - 1, c + 1],
            [r, c - 1],
            [r, c + 1],
            [r + 1, c - 1],
            [r + 1, c],
            [r + 1, c + 1]
          ];
          neighbors.forEach(([nr, nc]) => {
            const neighbor = cells.find(cell =>
              parseInt(cell.dataset.row) === nr &&
              parseInt(cell.dataset.col) === nc
            );
            if (neighbor && neighbor.dataset.state === "mate") {
              errors.add(cell);
              errors.add(neighbor);
            }
          });
        }
      });
      errors.forEach(cell => cell.classList.add("highlight"));
    }

    function checkWin() {
      if (document.querySelectorAll(".highlight").length > 0) return;
      const level = levels[currentLevelIndex];
      let rowCount = new Array(boardSize).fill(0);
      let colCount = new Array(boardSize).fill(0);
      let regionCount = {};
      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          const reg = level.board[row][col];
          regionCount[reg] = 0;
        }
      }
      cells.forEach(cell => {
        if (cell.dataset.state === "mate") {
          const r = parseInt(cell.dataset.row);
          const c = parseInt(cell.dataset.col);
          const reg = cell.dataset.region;
          rowCount[r]++;
          colCount[c]++;
          regionCount[reg]++;
        }
      });
      for (let i = 0; i < boardSize; i++) {
        if (rowCount[i] !== 1 || colCount[i] !== 1) return;
      }
      for (let reg in regionCount) {
        if (regionCount[reg] !== 1) return;
      }
      setTimeout(() => alert("춰Felicidades, ganaste!"), 300);
    }

    function resetGame() {
      clearTimeout(errorTimeout);
      cells.forEach(cell => {
        cell.textContent = "";
        cell.dataset.state = "empty";
        cell.classList.remove("highlight");
      });
    }

    function nextLevel() {
      currentLevelIndex = (currentLevelIndex + 1) % levels.length;
      document.getElementById("mapSelector").value = currentLevelIndex;
      loadLevel(currentLevelIndex);
    }

    function randomLevel() {
      currentLevelIndex = Math.floor(Math.random() * levels.length);
      document.getElementById("mapSelector").value = currentLevelIndex;
      loadLevel(currentLevelIndex);
    }

    function selectMap() {
      currentLevelIndex = parseInt(document.getElementById("mapSelector").value);
      loadLevel(currentLevelIndex);
    }

    loadLevel(currentLevelIndex);
  </script>
</body>
</html>
