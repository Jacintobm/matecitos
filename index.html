<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MATECITOS 🧉</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }
    h1 {
      margin-top: 20px;
    }
    /* Contenedor para el selector de mapa */
    #mapSelectorContainer {
      margin: 10px;
    }
    #mapSelector {
      padding: 5px;
      font-size: 16px;
    }
    /* Contenedor para el tablero, permite scroll horizontal en móviles */
    .board-container {
      width: 100%;
      overflow-x: auto;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .board {
      display: grid;
      gap: 2px;
      border: 2px solid #333;
      margin: auto;
    }
    .cell {
      /* El tamaño se fijará dinámicamente vía JS (50px para desktop, 40px para mobile) */
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      position: relative;
    }
    .cell.highlight {
      outline: 3px solid red;
    }
    .controls {
      margin: 10px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      min-width: 120px;
    }
    button:hover {
      background-color: #45a049;
    }
    .rules-pill {
      margin-top: 20px;
      background-color: #dff0d8;
      border: 1px solid #c3e6cb;
      border-radius: 25px;
      padding: 10px 20px;
      font-size: 14px;
      text-align: left;
      max-width: 400px;
    }
    .rules-pill p {
      margin: 5px 0;
    }
    .rules-pill ul {
      padding-left: 20px;
      margin: 0;
    }
    .rules-pill li {
      margin: 5px 0;
    }
    /* Media queries para pantallas pequeñas */
    @media (max-width: 480px) {
      .cell {
        font-size: 20px;
      }
      button {
        font-size: 14px;
        padding: 8px 16px;
        min-width: 100px;
      }
      .rules-pill {
        max-width: 90%;
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
  <h1>MATECITOS 🧉</h1>
  <!-- Selector de mapa (actualizado a 10 niveles) -->
  <div id="mapSelectorContainer">
    <select id="mapSelector" onchange="selectMap()">
      <option value="0">Mapa 1</option>
      <option value="1">Mapa 2</option>
      <option value="2">Mapa 3</option>
      <option value="3">Mapa 4</option>
      <option value="4">Mapa 5</option>
      <option value="5">Mapa 6</option>
      <option value="6">Mapa 7</option>
      <option value="7">Mapa 8</option>
      <option value="8">Mapa 9</option>
      <option value="9">Mapa 10</option>
    </select>
  </div>
  
  <div class="board-container">
    <div id="board" class="board"></div>
  </div>
  <div class="controls">
    <button onclick="resetGame()">Reset Nivel</button>
    <button onclick="nextLevel()">Siguiente Nivel</button>
    <button onclick="randomLevel()">Random</button>
  </div>
  <div class="rules-pill">
    <p><strong>Cómo jugar a Matecitos 🧉</strong></p>
    <ul>
      <li>Tu objetivo es tener exactamente un 🧉 en cada fila, columna y región de color.</li>
      <li>Pulsa una vez para colocar un 🧉 y pulsa dos veces para colocar una X. Usa la X para marcar dónde no se puede colocar un 🧉.</li>
      <li>Dos 🧉 no pueden tocarse entre sí, ni siquiera en diagonal.</li>
    </ul>
  </div>

  <script>
    // Colores base para niveles 5x5
    const colors5 = { "1": "#FFDDC1", "2": "#FFABAB", "3": "#FFC3A0", "4": "#D5AAFF", "5": "#85E3FF" };

    /* Definición de los 10 niveles nuevos (todos 5×5).
       Cada matriz es una representación del tablero.
       Cada número representa una región (el color se asigna mediante colors5).
       Se ha verificado que, para cada nivel, las celdas de cada región están conectadas ortogonalmente.
    */
    const levels = [
      { board: [
          [1,1,2,2,2],
          [1,3,3,2,2],
          [1,3,3,5,2],
          [4,3,5,5,5],
          [4,4,4,5,5]
        ], regionColors: colors5 },
      { board: [
          [1,1,1,2,2],
          [1,3,3,2,2],
          [1,3,4,5,5],
          [1,3,4,4,5],
          [1,3,4,4,4]
        ], regionColors: colors5 },
      { board: [
          [1,2,2,2,5],
          [1,1,3,2,5],
          [1,3,3,5,5],
          [4,3,3,5,5],
          [4,4,4,5,5]
        ], regionColors: colors5 },
      { board: [
          [1,1,5,5,2],
          [1,3,5,5,2],
          [1,3,5,5,2],
          [4,3,3,5,2],
          [4,4,3,5,2]
        ], regionColors: colors5 },
      { board: [
          [1,3,3,5,5],
          [1,1,3,5,2],
          [4,1,3,2,2],
          [4,4,3,2,2],
          [4,4,4,2,2]
        ], regionColors: colors5 },
      { board: [
          [1,1,5,5,5],
          [1,3,3,5,2],
          [1,3,3,2,2],
          [4,3,3,2,2],
          [4,4,3,2,2]
        ], regionColors: colors5 },
      { board: [
          [1,3,3,2,2],
          [1,1,3,2,2],
          [1,1,5,2,2],
          [4,4,5,5,5],
          [4,4,4,5,5]
        ], regionColors: colors5 },
      { board: [
          [1,1,3,3,2],
          [1,3,3,2,2],
          [1,3,5,2,2],
          [4,3,5,5,5],
          [4,4,4,5,5]
        ], regionColors: colors5 },
      { board: [
          [1,1,1,2,2],
          [1,4,4,2,2],
          [1,4,5,3,3],
          [1,4,5,5,5],
          [1,4,5,5,5]
        ], regionColors: colors5 },
      { board: [
          [1,1,3,3,3],
          [1,3,3,2,2],
          [1,3,5,2,2],
          [4,4,5,5,5],
          [4,4,4,5,5]
        ], regionColors: colors5 }
    ];

    let currentLevelIndex = 0;
    let board = document.getElementById("board");
    let cells = [];
    let boardSize;
    let errorTimeout;

    function loadLevel(levelIndex) {
      clearTimeout(errorTimeout);
      cells = [];
      board.innerHTML = "";
      const level = levels[levelIndex];
      boardSize = level.board.length;
      let cellSize = window.innerWidth < 480 ? 40 : 50;
      let gap = 2;
      board.style.gridTemplateColumns = `repeat(${boardSize}, ${cellSize}px)`;
      board.style.gridTemplateRows = `repeat(${boardSize}, ${cellSize}px)`;
      board.style.width = (boardSize * cellSize + (boardSize - 1) * gap) + "px";
      board.style.height = (boardSize * cellSize + (boardSize - 1) * gap) + "px";
      let regionKeys = Object.keys(level.regionColors).sort((a, b) => a - b);
      let offset = levelIndex % regionKeys.length;
      let newMapping = {};
      for (let i = 0; i < regionKeys.length; i++) {
        newMapping[regionKeys[i]] = level.regionColors[regionKeys[(i + offset) % regionKeys.length]];
      }
      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          cell.dataset.row = row;
          cell.dataset.col = col;
          cell.dataset.region = level.board[row][col];
          cell.style.backgroundColor = newMapping[cell.dataset.region];
          cell.dataset.state = "empty";
          cell.style.width = cellSize + "px";
          cell.style.height = cellSize + "px";
          cell.addEventListener("click", () => toggleCell(cell));
          board.appendChild(cell);
          cells.push(cell);
        }
      }
    }

    function toggleCell(cell) {
      if (cell.dataset.state === "empty") {
        cell.textContent = "🧉";
        cell.dataset.state = "mate";
      } else if (cell.dataset.state === "mate") {
        cell.textContent = "X";
        cell.dataset.state = "x";
      } else {
        cell.textContent = "";
        cell.dataset.state = "empty";
      }
      cell.classList.remove("highlight");
      clearTimeout(errorTimeout);
      errorTimeout = setTimeout(() => {
        checkErrors();
        checkWin();
      }, 1500);
    }

    function checkErrors() {
      cells.forEach(cell => cell.classList.remove("highlight"));
      const errors = new Set();
      const rows = {};
      const cols = {};
      const regions = {};
      cells.forEach(cell => {
        if (cell.dataset.state === "mate") {
          const r = cell.dataset.row;
          const c = cell.dataset.col;
          const reg = cell.dataset.region;
          if (!rows[r]) rows[r] = [];
          rows[r].push(cell);
          if (!cols[c]) cols[c] = [];
          cols[c].push(cell);
          if (!regions[reg]) regions[reg] = [];
          regions[reg].push(cell);
        }
      });
      Object.values(rows).forEach(group => {
        if (group.length > 1) group.forEach(cell => errors.add(cell));
      });
      Object.values(cols).forEach(group => {
        if (group.length > 1) group.forEach(cell => errors.add(cell));
      });
      Object.values(regions).forEach(group => {
        if (group.length > 1) group.forEach(cell => errors.add(cell));
      });
      cells.forEach(cell => {
        if (cell.dataset.state === "mate") {
          const r = parseInt(cell.dataset.row);
          const c = parseInt(cell.dataset.col);
          const neighbors = [
            [r - 1, c - 1],
            [r - 1, c],
            [r - 1, c + 1],
            [r, c - 1],
            [r, c + 1],
            [r + 1, c - 1],
            [r + 1, c],
            [r + 1, c + 1]
          ];
          neighbors.forEach(([nr, nc]) => {
            const neighbor = cells.find(cell =>
              parseInt(cell.dataset.row) === nr &&
              parseInt(cell.dataset.col) === nc
            );
            if (neighbor && neighbor.dataset.state === "mate") {
              errors.add(cell);
              errors.add(neighbor);
            }
          });
        }
      });
      errors.forEach(cell => cell.classList.add("highlight"));
    }

    function checkWin() {
      if (document.querySelectorAll(".highlight").length > 0) return;
      const level = levels[currentLevelIndex];
      let rowCount = new Array(boardSize).fill(0);
      let colCount = new Array(boardSize).fill(0);
      let regionCount = {};
      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          const reg = level.board[row][col];
          regionCount[reg] = 0;
        }
      }
      cells.forEach(cell => {
        if (cell.dataset.state === "mate") {
          const r = parseInt(cell.dataset.row);
          const c = parseInt(cell.dataset.col);
          const reg = cell.dataset.region;
          rowCount[r]++;
          colCount[c]++;
          regionCount[reg]++;
        }
      });
      for (let i = 0; i < boardSize; i++) {
        if (rowCount[i] !== 1 || colCount[i] !== 1) return;
      }
      for (let reg in regionCount) {
        if (regionCount[reg] !== 1) return;
      }
      setTimeout(() => alert("¡Felicidades, ganaste!"), 300);
    }

    function resetGame() {
      clearTimeout(errorTimeout);
      cells.forEach(cell => {
        cell.textContent = "";
        cell.dataset.state = "empty";
        cell.classList.remove("highlight");
      });
    }

    function nextLevel() {
      currentLevelIndex = (currentLevelIndex + 1) % levels.length;
      document.getElementById("mapSelector").value = currentLevelIndex;
      loadLevel(currentLevelIndex);
    }

    function randomLevel() {
      currentLevelIndex = Math.floor(Math.random() * levels.length);
      document.getElementById("mapSelector").value = currentLevelIndex;
      loadLevel(currentLevelIndex);
    }

    function selectMap() {
      currentLevelIndex = parseInt(document.getElementById("mapSelector").value);
      loadLevel(currentLevelIndex);
    }

    loadLevel(currentLevelIndex);
  </script>
</body>
</html>
